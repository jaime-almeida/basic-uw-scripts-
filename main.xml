<StGermainData xmlns="http://www.vpac.org/StGermain/XML_IO_Handler/Jun2003">
	<!-- This is what actually initiates UW, must be at the TOP of the file  -->
	<list name="import">
		<param> Underworld </param>
		<param> CartesianEarthBox </param>
	</list>
	
	<!-- Path to the CartesianEarthBox which is in the bleedingEdge folder (FUNDAMENTAL) -->
	<include>/home/jalmeida/uw/bleedingEdge/CartesianEarthBox/InputFiles/_thermoMechanicalFlow.xml</include> 
	
	<!-- Fundamental UW modules required to run the model (should mostly not change) -->
	<include>Underworld/REP_Setup.xml</include>
	<include>Underworld/MaterialIndexField.xml</include>
	<include>Underworld/ViscosityField.xml</include>
	
	<!-- List of additional XML files to be included  -->
	<include>main_V.xml</include>
	<include>main_T.xml</include>
	<!-- <include>main_NB.xml</include> --> <!-- optional file -->
	
	<!-- Geometrical definition, number of dimensions and axis size -->
	<param name="dim"> 2 </param>
	<param name="minX" units="km"> 0.0  </param>
	<param name="maxX" units="km"> 5000.0 </param>
	<param name="minY" units="km"> 340.0 </param>
	<param name="maxY" units="km"> 1000.0 </param>
	<param name="minZ" units="km"> 0.0  </param>
	<param name="maxZ" units="km"> 0.0  </param>
	
	<!-- Model resolution  -->
	<param name="elementResI"> 768 </param> <!-- Resolution along the x axis -->
	<param name="elementResJ"> 192 </param> <!-- Resolution along the y axis -->
	<param name="elementResK"> 1 </param>   <!-- Resolution along the z axis -->
	
	<!-- Gravity acceleration, generally useful and not to be touched if we're simulating Earth :) -->
	<param name="Gravity" units="m/s^2"> 9.81 </param>

	<!-- Specify run duration and output frequency -->
	<param name="maxTimeSteps"> 2500 </param>
	<param name="dumpEvery"> 50 </param> <!-- How often do we get outputs -->
	<param name="checkpointEvery"> 50 </param>  <!-- How often are we saving a restart database -->
	
	<!-- Specify the tolerance for the solver -->
	<param name="nonLinearTolerance"> 0.1 </param>
	
	<!-- Path to save the model output (change according to your needs) -->
	<param name="outputPath">/example/path/to/save/your/model</param>
	
	<!-- Useful plugins which are constant between models, again should not be changed -->
	<list name="plugins" mergeType="merge">
		<struct>
			<param name="Type">StgFEM_FrequentOutput</param>
			<param name="Context">context</param>
		</struct>
		<struct>
			<param name="Type">Underworld_Vrms</param>
			<param name="Context">context</param>
			<param name="GaussSwarm">gaussSwarm</param>
			<param name="VelocityField">VelocityField</param>
		</struct>
		<struct>
			<param name="Type">StgFEM_CPUTime</param>
			<param name="Context">context</param>
		</struct>
		<struct>
			<param name="Type">Underworld_PressureCalibration</param>
			<param name="Context">context</param>
			<param name="UsingTopPressure">true</param>
		</struct>
	</list>

<!-- ============================================================ -->
<!-- |                                                           |-->
<!-- |       THIS IS WHERE WE START TO DEFINE THE MODEL          |-->
<!-- |                                                           |-->
<!-- ============================================================ -->

	<struct name="components" mergeType="merge">
	
		<!-- This just tells the Underworld code where to get the information from -->
		<struct name="context">
			<param name="Type">UnderworldContext</param>
		</struct>
		
		<!-- Define the properties for the Particle-In-Cell method -->
		<struct name="weights" mergeType="replace">
			<param name="Inflow">True</param>      <!-- Do we allow particles to inflow? (while being True it may not be working if the model is closed) -->
			<param name="Type">PCDVC</param>       <!-- Type of PIC method  -->
			<param name="resolutionX">20</param>
			<param name="resolutionY">20</param>
			<param name="resolutionZ">20</param>
			<param name="lowerT">5</param>         <!-- Delete the particle if it occupies under 5% of total cell volume -->
			<param name="upperT">35</param>        <!-- Split the particle if it occupies over 35% of total cell volume -->
			<param name="maxDeletions">5</param> 
			<param name="maxSplits">5</param>
			<param name="splitInInterfaceCells">false</param> <!-- Do we allow cells to be split along the interfaces? Generally set to "false" to prevent interface diffusion. -->
			<param name="MaterialPointsSwarm">materialSwarm</param>
		</struct>
		
		<!-- Scaling parameters, no need to mess with them. -->
		<struct name="default_scaling">
			<param name="Type">Scaling</param>
			<param name="spaceCoefficient_meters">       1  </param>
			<param name="timeCoefficient_seconds">       1  </param>
			<param name="massCoefficient_kilograms">     1  </param>
			<param name="temperatureCoefficient_kelvin"> 1  </param>
		</struct>
		
		<!-- Everywhere shape. This just covers the entire model and can be useful to use in boolean operations -->
		<struct name="everywhere">
			<param name="Type">Everywhere</param>
		</struct>
		
		<!-- ============================================================ -->
		<!-- |                                                           |-->
		<!-- |                  DEFINE THE MODEL GEOMETRY                |-->
		<!-- |                                                           |-->
		<!-- ============================================================ -->
		
		<!-- Within this section we define all geometric properties of the model, which includes material (lithological) shape and thermal shapes. -->
		
		<!-- We define the Upper Mantle as essentially covering the entire model. This is not an issue since we then overlay the other shapes. -->
		<!-- Doing it like this prevents the formation of gaps in the model which would simply crash and not provide much help -->
		<struct name="upperMantleShape">
			<param name="Type">Box</param>
			<param name="startX" units="km"> 0.0 </param>
			<param name="endX" units="km"> 5000.0 </param>
			<param name="startY" units="km"> 340.0</param>
			<param name="endY" units="km"> 1000.0  </param>
		</struct>
		
		<!-- We define most other shapes as polygons, in which we indicate the vertex following a clockwise or counter-clockwise order.  -->
		<!-- If the last vertex connects to the first along a horizontal or vertical line, we do not need to define it -->
		<struct name="overridingCrustShape">
			<param name="Type">PolygonShape</param>
			<list name="vertices">
				<asciidata>
					<columnDefinition name="x" type="double" units="km"/>
					<columnDefinition name="y" type="double" units="km"/>
					50 1000
					300 990
					1970 990
					1970 1000
				</asciidata>
			</list>
		</struct>
		
		<struct name="slabCrustShape">
			<param name="Type">PolygonShape</param>
			<list name="vertices">
				<asciidata>
					<columnDefinition name="x" type="double" units="km"/>
					<columnDefinition name="y" type="double" units="km"/>
					2000 1000
					1720 910
					1724.1 902.3
					2000 990
					4700 990
					4950 1000
				</asciidata>
			</list>
		</struct>
		
		<struct name="weakzoneShape">
			<param name="Type">PolygonShape</param>
			<list name="vertices">
				<asciidata>
					<columnDefinition name="x" type="double" units="km"/>
					<columnDefinition name="y" type="double" units="km"/>
					2000 1000
					1720 910
					1715 915
					1970 1000
				</asciidata>
			</list>
		</struct>
		
		<struct name="overridingLithosphereShape">
			<param name="Type">PolygonShape</param>
			<list name="vertices">
				<asciidata>
					<columnDefinition name="x" type="double" units="km"/>
					<columnDefinition name="y" type="double" units="km"/>
					50 1000
					300 940
					1780 940
					1810 940
					1940 990
					300 990
				</asciidata>
			</list>
		</struct>
		
		<struct name="slabLithosphereShape">
			<param name="Type">PolygonShape</param>
			<list name="vertices">
				<asciidata>
					<columnDefinition name="x" type="double" units="km"/>
					<columnDefinition name="y" type="double" units="km"/>
					2020 920
					1760 840
					1724.1 902.3
					2000 990
					2700 990
					3400 990
					4700 990
					4950 1000
					4700 920
					3400 920
					2700 920
				</asciidata>
			</list>
		</struct>

		<!-- ============================================================ -->
		<!-- |                                                           |-->
		<!-- |                  DEFINE THE THERMAL SHAPES                |-->
		<!-- |                                                           |-->
		<!-- ============================================================ -->

		<!-- In this section we define the thermal shapes for the individual model components. These will later be used in the thermal file (main_T.xml) 
			to generate the initial thermal conditions for the model.-->
		
		<!-- To distinguish them from the previous material shapes, we simply add a reference to "TShape" on the variable name -->
		<struct name="overridingRidgeTShape">
			<param name="Type">Box</param>
			<param name="startX" units="km"> 50.0 </param>
			<param name="endX" units="km"> 300.0 </param>
			<param name="startY" units="km"> 910</param>
			<param name="endY" units="km"> 1000.0  </param>
		</struct>
		
		<struct name="overridingLithosphereTShape">
			<param name="Type">Box</param>
			<param name="startX" units="km"> 300.0 </param>
			<param name="endX" units="km"> 1970.0 </param>
			<param name="startY" units="km"> 910.0 </param>
			<param name="endY" units="km"> 1000.0  </param>
		</struct>
		
		<struct name="slabLithosphereLeftTShape">
			<param name="Type">Box</param>
			<param name="startX" units="km"> 1970.0 </param>
			<param name="endX" units="km"> 3100.0 </param>
			<param name="startY" units="km"> 850.0 </param>
			<param name="endY" units="km"> 1000.0  </param>
		</struct>
		
		<struct name="slabLithosphereRightTShape">
			<param name="Type">Box</param>
			<param name="startX" units="km"> 3400.0 </param>
			<param name="endX" units="km"> 4700.0 </param>
			<param name="startY" units="km"> 850.0 </param>
			<param name="endY" units="km"> 1000.0  </param>
		</struct>
		
		<struct name="plateauTShape">
			<param name="Type">Box</param>
			<param name="startX" units="km"> 3100.0 </param>
			<param name="endX" units="km"> 3800.0 </param>
			<param name="startY" units="km"> 850.0 </param>
			<param name="endY" units="km"> 1000.0  </param>
		</struct>
		
		<struct name="slabRidgeTShape">
			<param name="Type">Box</param>
			<param name="startX" units="km"> 4700.0 </param>
			<param name="endX" units="km"> 4950.0 </param>
			<param name="startY" units="km"> 850.0 </param>
			<param name="endY" units="km"> 1000.0  </param>
		</struct>
		
		<struct name="slabPerturbationUpTShape">
			<param name="Type">PolygonShape</param>
			<list name="vertices">
				<asciidata>
					<columnDefinition name="x" type="double" units="km"/>
					<columnDefinition name="y" type="double" units="km"/>
					1760 840
					1727 899
					1970 970
					1970 910
				</asciidata>
			</list>
		</struct>
		
		<struct name="crustPerturbationUpTShape">
			<param name="Type">PolygonShape</param>
			<list name="vertices">
				<asciidata>
					<columnDefinition name="x" type="double" units="km"/>
					<columnDefinition name="y" type="double" units="km"/>
					1728.1 897.3
					1720 910
					1970 990
					1970 970
				</asciidata>
			</list>
		</struct>
		
		<!-- We used a boolean operation to unite the two slab perturbations which create the initial slab.  -->
		<struct name="originalPerturbationTShape">
			<param name="Type">Union</param>
			<list name="shapes">
				<param>crustPerturbationUpTShape</param>
				<param>slabPerturbationUpTShape</param>
			</list>
		</struct>
		
		<!-- ============================================================ -->
		<!-- |                                                           |-->
		<!-- |                DEFINE THE VISCOUS CREEP LAWS              |-->
		<!-- |                                                           |-->
		<!-- ============================================================ -->
		
		<!-- We need this structure to keep our effective viscosity within reasonable values. Underworld employs 10^22 time scaling which is multiplied here -->
		<struct name="viscosityLimiter">
			<param name="Type">ViscosityLimiter</param>
			<param name="maxViscosity" units="Pa*s">1e2</param>  <!-- True value: 10^24 Pa.s -->
			<param name="minViscosity" units="Pa*s">1e-3</param> <!-- True value: 10^18 Pa.s -->
		</struct>
		
		<!-- Only two viscous creep laws are implemented in this model: 
				1) Dry olivine viscous creep law for the upper mantle
				2) Plagioclase law for the overriding plate crust -->
		
		<!-- The equation which defines this law is: -->
		
		<!-- eta_eff = 0.5*A^(-1/n) * E_II^((1/n)-n) * exp((Ea + Va*P)/(nRT)) -->
		
		<!-- This is described and explained in Chapter 2 - eq. 2.19 -->
		<struct name="upperMantleViscosity">
			<param name="Type">PatriceArrhenius</param>
			<param name="StrainRateInvariantField">StrainRateInvariantField</param>    <!-- E_II -->
			<param name="TemperatureField">TemperatureField</param>                    <!-- T -->
			<param name="PressureField">PressureField</param>                          <!-- P -->
			<param name="StressExponent"> 3.5 </param>                                 <!-- n -->
			<param name="PreExponentialFactor" units="(MPa)^-3.5*s^-1">5.49e26</param> <!-- A -->
			<param name="ActivationEnergy" units="J/mol">5.3e5</param>                 <!-- Ea -->
			<param name="ActivationVolume" units="m^3/mol">10e-6</param>               <!-- Va -->
			<param name="DefaultStrainRateInvariant" units="s^-1">1.0e5</param>        <!-- E_II for the initial estimate -->
		</struct>
		
		<struct name="overridingCrustViscosity">
			<param name="Type">PatriceArrhenius</param>
			<param name="StrainRateInvariantField">StrainRateInvariantField</param>
			<param name="TemperatureField">TemperatureField</param>
			<param name="PressureField">PressureField</param>
			<param name="StressExponent">3.0</param>
			<param name="PreExponentialFactor" units="(MPa)^-3*s^-1">5.1e16</param>
			<param name="ActivationEnergy" units="J/mol">2.38e5</param>
			<param name="ActivationVolume" units="m^3/mol">0</param>
			<param name="DefaultStrainRateInvariant" units="s^-1">1.0e5</param>
		</struct>
		
		<!-- This defines a constant viscosity with a specified value -->
		<struct name="weakzoneViscosity">
			<param name="Type">MaterialViscosity</param>
			<param name="eta0" units="Pa*s">1e-3</param>
		</struct>
		
		<!-- The following structures define constant viscosity areas along the ridges of the model, to prevent cold drips from forming -->
		<struct name="viscosityFixLeft">
			<param name="Type"> ViscosityImposedDepth </param>
			<param name="Viscosity" units="Pa*s"> 1e-3 </param>
			<param name="minx" units="km">  0 </param>
			<param name="maxx" units="km">  80 </param>
			<param name="miny" units="km">  960 </param>
			<param name="maxy" units="km">  1032 </param>
		</struct>
		
		<struct name="viscosityFixRight">
			<param name="Type"> ViscosityImposedDepth </param>
			<param name="Viscosity" units="Pa*s"> 1e-3 </param>
			<param name="minx" units="km">  4920 </param>
			<param name="maxx" units="km">  5000 </param>
			<param name="miny" units="km">  960 </param>
			<param name="maxy" units="km">  1032 </param>
		</struct>
		
		<struct name="upperMantleTopFix">
			<param name="Type"> ViscosityImposedDepth </param>
			<param name="Viscosity" units="Pa*s"> 1e2 </param>
			<param name="minx" units="km">  30 </param>
			<param name="maxx" units="km">  4970 </param>
			<param name="miny" units="km">  982 </param>
			<param name="maxy" units="km">  996 </param>
		</struct>
		
		<struct name="upperMantleBotFix">
			<param name="Type"> ViscosityImposedDepth </param>
			<param name="Viscosity" units="Pa*s"> 1e2 </param>
			<param name="minx" units="km">  80 </param>
			<param name="maxx" units="km">  4920 </param>
			<param name="miny" units="km">  976 </param>
			<param name="maxy" units="km">  982 </param>
		</struct>
		
		<!-- ============================================================ -->
		<!-- |                                                           |-->
		<!-- |                DEFINE THE PLASTIC CREEP LAWS              |-->
		<!-- |                                                           |-->
		<!-- ============================================================ -->
		
		<!-- Here we define the plastic creep law, also known as the yielding effect. This is a pseudo-brittle rheology which approximates purely brittle deformation. -->
		
		<!-- Only simple Drucker-Prager plastic creep was implemented in this model. -->
		
		<!-- The equations which defines this creep law are: -->
		
		<!--  sqrt(dev_stress_II) = P*sin(phi) + C*cos(phi) -->
		<!--  eta_eff = dev_stress_II / (2*strain_rate)-->
		
		
		<!-- This is described and explained in Chapter 2 - eq. 2.20-2.21 -->
		<struct name="upperMantleYielding">
			<param name="Type">DruckerPrager</param>
			<param name="StrainRateField">StrainRateField</param>         <!-- strain rate -->
			<param name="PressureField">recoveredPressureField</param>    <!-- P -->
			<param name="MaterialPointsSwarm">materialSwarm</param>
			<param name="IntegrationSwarm">picIntegrationPoints</param>
			<param name="Context">context</param>
			<param name="cohesion" units="MPa">30.0</param>               <!-- C -->
			<param name="cohesionAfterSoftening" units="MPa">3.0</param>  <!-- Post-yielding cohesion, generally 10% of initial value -->
			<param name="frictionCoefficient">0.25 </param>               <!-- tan(phi) -->
			<param name="frictionCoefficientAfterSoftening">0.025</param> <!-- Post-yielding tan(phi), generally 10% of initial value -->
			<param name="minimumViscosity" units="Pa*s">1e-3</param>      <!-- viscosity limiter to ensure realistic values -->
		</struct>
		
		<struct name="plateauLithosphereYielding">
			<param name="Type">DruckerPrager</param>
			<param name="StrainRateField">StrainRateField</param>
			<param name="PressureField">recoveredPressureField</param>
			<param name="MaterialPointsSwarm">materialSwarm</param>
			<param name="IntegrationSwarm">picIntegrationPoints</param>
			<param name="Context">context</param>
			<param name="StrainWeakening">strainWeakening</param>
			<param name="cohesion" units="MPa">30.0</param>
			<param name="cohesionAfterSoftening" units="MPa">3.0</param>
			<param name="frictionCoefficient">0.25</param>
			<param name="frictionCoefficientAfterSoftening">0.025</param>
			<param name="minimumViscosity" units="Pa*s">1e-3</param>
		</struct>
		
		<struct name="overridingCrustYielding">
			<param name="Type">DruckerPrager</param>
			<param name="StrainRateField">StrainRateField</param>
			<param name="PressureField">recoveredPressureField</param>
			<param name="MaterialPointsSwarm">materialSwarm</param>
			<param name="IntegrationSwarm">picIntegrationPoints</param>
			<param name="Context">context</param>
			<param name="cohesion" units="MPa">20.0</param>
			<param name="cohesionAfterSoftening" units="MPa">2.0</param>
			<param name="frictionCoefficient">0.25 </param>
			<param name="frictionCoefficientAfterSoftening">0.025</param>
			<param name="minimumViscosity" units="Pa*s">1e-3</param>
		</struct>
		
		<struct name="slabCrustYielding">
			<param name="Type">DruckerPrager</param>
			<param name="StrainRateField">StrainRateField</param>
			<param name="PressureField">recoveredPressureField</param>
			<param name="MaterialPointsSwarm">materialSwarm</param>
			<param name="IntegrationSwarm">picIntegrationPoints</param>
			<param name="Context">context</param>
			<param name="cohesion" units="MPa">20</param>
			<param name="cohesionAfterSoftening" units="MPa">2.0</param>
			<param name="frictionCoefficient">0.25 </param>
			<param name="frictionCoefficientAfterSoftening">0.025</param>
			<param name="minimumViscosity" units="Pa*s">1e-3</param>
		</struct>
		
		<!-- ============================================================ -->
		<!-- |                                                           |-->
		<!-- |                DEFINE THE PEIERLS CREEP LAWS              |-->
		<!-- |                         (optional)                        |-->
		<!-- ============================================================ -->
		
		
		<!-- These are optional creep laws which correspond, in effect, to stress limiters. 
		     Rheologically, they correspond to low temperature, low pressure viscous creeps-->
			 
		<!-- Numerically, when a stress value overcomes the maximum, the viscosity of the material is reduced to avoid any more stress build up -->
		
		<!-- An explanation of this effect can be found in Regenauer-Lieb et al. (2001) (DOI: 10.1126/science.1063891) -->
		
		<struct name="upperMantlePeierls">
			<param name="Type"> Byerlee </param>
			<param name="cohesion" units="MPa">900</param> <!-- Maximum stress value-->
			<param name="depthCoefficient"> 0.0 </param>
			<param name="minimumViscosity" units="Pa*s">1e-3</param>
			<param name="StrainRateField"> StrainRateField </param>
			<param name="MaterialPointsSwarm">materialSwarm</param>
			<param name="FeMesh"> linearMesh </param>
			<param name="BlockGeometry"> geometry </param>
		</struct>
		
		<struct name="overridingCrustPeierls">
			<param name="Type"> Byerlee </param>
			<param name="cohesion" units="MPa">900</param>
			<param name="depthCoefficient"> 0.0 </param>
			<param name="minimumViscosity" units="Pa*s">1e-3</param>
			<param name="StrainRateField"> StrainRateField </param>
			<param name="MaterialPointsSwarm">materialSwarm</param>
			<param name="FeMesh"> linearMesh </param>
			<param name="BlockGeometry"> geometry </param>
		</struct>
		
		<!-- The Peierls yield associated with the slab crust allows it to become much stronger after subducting. -->
		
		<!-- At a depth lower than 160 km, the maximum stress is 2.5 MPa. -->
		<!-- At a depth between 160 and 180 km, the maximum stress linearly increases from 2.5 to 900 MPa. -->
		<!-- At a depth higher than 180 km, the maximum stress is 900 MPa. -->
		
		<struct name="slabCrustPeierls">
			<param name="Type"> Byerlee </param>
			<param name="cohesion" units="MPa">2.5</param>
			<param name="cohesion2" units="MPa">900</param>
			<param name="depth2" units="km">160</param>
			<param name="depth3" units="km">180</param>
			<param name="depthCoefficient"> 0.0 </param>
			<param name="minimumViscosity" units="Pa*s">1e-3</param>
			<param name="StrainRateField"> StrainRateField </param>
			<param name="MaterialPointsSwarm">materialSwarm</param>
			<param name="FeMesh"> linearMesh </param>
			<param name="BlockGeometry"> geometry </param>
		</struct>
		
		<!-- ============================================================ -->
		<!-- |                                                           |-->
		<!-- |                DEFINE THE STRAIN WEAKENING                |-->
		<!-- |                      (optional)                           |-->
		<!-- ============================================================ -->
		
		<!-- This optional structure allows us to employ permanent weakening of the materials with increasing deformation.  -->
		<!-- TODO: CHECK THIS TO MAKE SURE IT IS EXPLAINED #### dont forget this :p ####-->
		
		<struct name="strainWeakening">
			<param name="Type">StrainWeakening</param>
			<param name="TimeIntegrator">timeIntegrator</param>
			<param name="MaterialPointsSwarm">materialSwarm</param>
			<param name="softeningStrain">0.5</param>
			<param name="initialDamageFraction">0.0</param>     <!-- how damaged is it at the start -->
			<param name="initialDamageWavenumber">0.</param>    <!-- initial weakening parameters -->
			<param name="initialDamageFactor">0.</param>        <!-- initial weakening parameters -->
			<param name="healingRate">0.0</param> <!-- How much can it recover over time. In this case, it is permanently weak. -->
		</struct>
		
		
		<!-- ============================================================ -->
		<!-- |                                                           |-->
		<!-- |                 ALLOCATE RHEOLOGY MATERIALS               |-->
		<!-- |                                                           |-->
		<!-- ============================================================ -->

		<!-- This is the most important section of any UW code. It joins the previously created material geometry shapes with their respective rheological properties -->
		<!-- The order of the rheology materials should be from largest to smallest, to allow for the proper overlaps. In this case, the first is the upper mantle. -->
		
		<!-- Furthermore, within the RheologyMaterial, the order of the Rheologies is also important and must always follow: -->
		<!-- 1) Viscous creep -->
		<!-- 2) Plastic creep -->
		<!-- 3) Peierls creep (optional) -->
		<!-- 4) Specific fixes  -->
		<!-- 5) Viscosity limiter -->
		
		<struct name="upperMantleRheology">
			<param name="Type">RheologyMaterial</param>
			<param name="Shape">upperMantleShape</param> <!-- Target shape -->
			<list name="Rheology"> <!-- List of rheologies to be allocated, for which the order is highly relevant! -->
				<param> upperMantleViscosity</param>
				<param> upperMantleYielding </param>
				<param> upperMantlePeierls </param>
				<param> viscosityFixLeft </param>
				<param> viscosityFixRight </param>
				<param> viscosityLimiter</param>
			</list>
			<param name="DensityLabel"> upperMantleDensity </param>                             <!-- Density structure for this material (defined later) -->
			<param name="DiffusivityLabel"> TheDiffusivity </param>                             <!-- Thermal diffusivity for this material (defined later) -->
			<param name="CpLabel"> TheCp </param>                                               <!-- heat capacity for this material (defined later) -->
			<param name="ThermalExpansivityLabel"> TheAlpha </param>                            <!-- Thermal expansivity for this material (defined later) -->
			<param name="RadiogenicHeatProductionLabel" units="kg/(m*s*s*s)"> 0.022e16 </param> <!-- Radiogenic heat production for this material -->
			<param name="LatentHeatFusionLabel"> 0.0 </param>                                   <!-- Latent heat production for this material -->
		</struct>
		
		<struct name="overridingLithosphereRheology">
			<param name="Type">RheologyMaterial</param>
			<param name="Shape">overridingLithosphereShape</param>
			<list name="Rheology">
				<param> upperMantleViscosity</param>
				<param> upperMantleYielding </param>
				<param> upperMantlePeierls </param>
				<param> viscosityLimiter</param>
			</list>
			<param name="DensityLabel"> upperMantleDensity </param>
			<param name="DiffusivityLabel"> TheDiffusivity </param>
			<param name="CpLabel"> TheCp </param>
			<param name="ThermalExpansivityLabel"> TheAlpha </param>
			<param name="RadiogenicHeatProductionLabel" units="kg/(m*s*s*s)"> 0.022e16</param>
			<param name="LatentHeatFusionLabel"> 0.0 </param>
		</struct>
		
		<struct name="slabLithosphereRheology">
			<param name="Type">RheologyMaterial</param>
			<param name="Shape">slabLithosphereShape</param>
			<list name="Rheology">
				<param> upperMantleViscosity</param>
				<param> upperMantleYielding </param>
				<param> upperMantlePeierls </param>
				<param> viscosityLimiter</param>
			</list>
			<param name="DensityLabel"> upperMantleDensity </param>
			<param name="DiffusivityLabel"> TheDiffusivity </param>
			<param name="CpLabel"> TheCp </param>
			<param name="ThermalExpansivityLabel"> TheAlpha </param>
			<param name="RadiogenicHeatProductionLabel" units="kg/(m*s*s*s)"> 0.022e16 </param>
			<param name="LatentHeatFusionLabel"> 0.0 </param>
		</struct>
		
		<struct name="slabCrustRheology">
			<param name="Type">RheologyMaterial</param>
			<param name="Shape">slabCrustShape</param>
			<list name="Rheology">
				<param> upperMantleViscosity  </param>
				<param> slabCrustYielding </param>
				<param> slabCrustPeierls </param>
				<param> viscosityLimiter</param>
			</list>
			<param name="DensityLabel"> upperMantleDensity </param>
			<param name="DiffusivityLabel"> TheDiffusivity </param>
			<param name="CpLabel"> TheCp </param>
			<param name="ThermalExpansivityLabel"> TheAlpha </param>
			<param name="RadiogenicHeatProductionLabel" units="kg/(m*s*s*s)"> 0.25e16 </param>
			<param name="LatentHeatFusionLabel"> 0.0 </param>
		</struct>
		
		<struct name="overridingCrustRheology">
			<param name="Type">RheologyMaterial</param>
			<param name="Shape">overridingCrustShape</param>
			<list name="Rheology">
				<param> upperMantleViscosity </param>
				<param> slabCrustYielding </param>
				<param> slabCrustPeierls </param>
				<param> viscosityLimiter</param>
			</list>
			<param name="DensityLabel"> overridingCrustDensity </param>
			<param name="DiffusivityLabel"> TheDiffusivity </param>
			<param name="CpLabel"> TheCp </param>
			<param name="ThermalExpansivityLabel"> TheAlpha </param>
			<param name="RadiogenicHeatProductionLabel" units="kg/(m*s*s*s)"> 1.5e16 </param>
			<param name="LatentHeatFusionLabel"> 0.0 </param>
		</struct>
				
		<struct name="weakzoneRheology">
			<param name="Type">RheologyMaterial</param>
			<param name="Shape">weakzoneShape</param>
			<list name="Rheology">
				<param> weakzoneViscosity</param>
			</list>
			<param name="DensityLabel"> weakzoneDensity </param>
			<param name="DiffusivityLabel"> TheDiffusivity </param>
			<param name="CpLabel"> TheCp </param>
			<param name="ThermalExpansivityLabel"> TheAlpha </param>
			<param name="RadiogenicHeatProductionLabel" units="kg/(m*s*s*s)"> 1.5e16 </param>
			<param name="LatentHeatFusionLabel"> 0.0 </param>
		</struct>
		
		
		<!-- ============================================================ -->
		<!-- |                                                           |-->
		<!-- |              DEFINE HEAT EQUATION PARAMETERS              |-->
		<!-- |                                                           |-->
		<!-- ============================================================ -->
		
		<!-- In this section of the code, we allocate the parameters which govern the heat equation -->
		
		<!-- Create a temperature property on the particles so that advection can occur. -->
		<struct name="tempPpc">
			<param name="Type">Ppc_Variable</param>
			<param name="FieldVariable">TemperatureField</param>
			<param name="Manager">thePpcManager</param>
		</struct>
		
		<!-- Define the diffusivity  -->
		<struct name="TheDiffusivity">
			<param name="Type">Ppc_Constant</param>
			<param name="Value" units="m*m/s">1e16</param>
		</struct>
		
		<!-- Define heat capacity -->
		<struct name="TheCp">
			<param name="Type">Ppc_Constant</param>
			<param name="Value" units="J/(kg*K)">1e3</param>
		</struct>
		
		<!-- Define the thermal expansivity  -->
		<struct name="TheAlpha">
			<param name="Type">Ppc_Constant</param>
			<param name="Value" units="K^-1">3e-5</param>
		</struct>
		
		<!-- Define compressibility  -->
		<struct name="TheBeta">
			<param name="Type">Ppc_Constant</param>
			<param name="Value" units="Pa^-1">1e-11</param>
		</struct>
		
		<!-- ============================================================ -->
		<!-- |                                                           |-->
		<!-- |                   DEFINE MATERIAL DENSITY                 |-->
		<!-- |                                                           |-->
		<!-- ============================================================ -->
		
		<!-- In this model, the densities are temperature dependent so we need to define the parameters which govern this dependency. -->
		
		<!-- The equation which defines this pressure and temperature dependency is: -->
		
		<!-- rho = rho_reference * (1 - alpha*(T - T_reference) - beta*(P - P_reference) -->
		
		<struct name="upperMantleDensity">
			<param name="Type">Ppc_LinearDensity</param>               <!-- Where the density will be saved -->
			<param name="Temperature">tempPpc</param>                  <!-- obtain the temperature from the thermal particles-->
			<param name="Compressibility">TheBeta</param>              <!-- compressibility  -->
			<param name="ThermalExpansivity">TheAlpha</param>          <!-- expansibility -->
			<param name="Pressure"> default_pressure_ppc </param>      <!-- where the pressure value is stored-->
			<param name="ReferenceTemperature" units="K">273</param> 
			<param name="ReferenceDensity" units="kg/m^3">3300</param>
			<param name="ReferencePressure">0.0</param>
			<param name="ExternalFunction"> 1.0 </param>               <!-- Additional fix for the correct use of compressibility -->
		</struct> 
		
		<struct name="overridingCrustDensity">
			<param name="Type">Ppc_LinearDensity</param>
			<param name="Temperature">tempPpc</param>
			<param name="Compressibility">TheBeta</param>
			<param name="ThermalExpansivity">TheAlpha</param>
			<param name="Pressure"> default_pressure_ppc </param>
			<param name="ExternalFunction"> 0.0 </param>
			<param name="ReferenceTemperature" units="K">273</param>
			<param name="ReferenceDensity" units="kg/m^3">3300</param>
			<param name="ReferencePressure">0.0</param>
		</struct>
		
		<struct name="lowerMantleDensity">
			<param name="Type">Ppc_LinearDensity</param>
			<param name="Temperature">tempPpc</param>
			<param name="Compressibility">TheBeta</param>
			<param name="ThermalExpansivity">TheAlpha</param>
			<param name="Pressure"> default_pressure_ppc </param>
			<param name="ExternalFunction"> 0.0 </param>
			<param name="ReferenceTemperature" units="K">273</param>
			<param name="ReferenceDensity" units="kg/m^3">3650</param>
			<param name="ReferencePressure">0.0</param>
		</struct>
		
		<struct name="weakzoneDensity">
			<param name="Type">Ppc_LinearDensity</param>
			<param name="Temperature">tempPpc</param>
			<param name="Compressibility">TheBeta</param>
			<param name="ThermalExpansivity">TheAlpha</param>
			<param name="Pressure"> default_pressure_ppc </param>
			<param name="ExternalFunction"> 1.0 </param>
			<param name="ReferenceTemperature" units="K">273</param>
			<param name="ReferenceDensity" units="kg/m^3">3330</param>
			<param name="ReferencePressure">0.0</param>
		</struct>
		
		<struct name="PlateauCrustDensity">
			<param name="Type">Ppc_LinearDensity</param>
			<param name="Temperature">tempPpc</param>
			<param name="Compressibility">TheBeta</param>
			<param name="ThermalExpansivity">TheAlpha</param>
			<param name="Pressure"> default_pressure_ppc </param>
			<param name="ExternalFunction"> 0.0 </param>
			<param name="ReferenceTemperature" units="K">273</param>
			<param name="ReferenceDensity" units="kg/m^3">2800</param>
			<param name="ReferencePressure">0.0</param>
		</struct>
		
		<struct name="PlateauMantleDensity">
			<param name="Type">Ppc_LinearDensity</param>
			<param name="Temperature">tempPpc</param>
			<param name="Compressibility">TheBeta</param>
			<param name="ThermalExpansivity">TheAlpha</param>
			<param name="Pressure"> default_pressure_ppc </param>
			<param name="ExternalFunction"> 1.0 </param>
			<param name="ReferenceTemperature" units="K">273</param>
			<param name="ReferenceDensity" units="kg/m^3">3220</param>
			<param name="ReferencePressure">0.0</param>
		</struct>
		
		<!-- ============================================================ -->
		<!-- |                                                           |-->
		<!-- |          CREATE THE STRAIN RATE INVARIANT FIELD           |-->
		<!-- |                                                           |-->
		<!-- ============================================================ -->
		
		<!-- This simply adds this as an output variable in the end -->
		<struct name="StrainRateInvariantField" mergeType="merge">
			<param name="outputUnits" mergeType="replace">s^-1</param>
		</struct>
	</struct>
	

<!-- ============================================================ -->
<!-- |                                                           |-->
<!-- |                     MODEL IS NOW DEFINED                  |-->
<!-- |                                                           |-->
<!-- ============================================================ -->


<!-- Define what variables to store when restarting the models -->
	<list name="FieldVariablesToCheckpoint" mergeType="merge">
		<param>ViscosityField</param>
		<param>MaterialIndexField</param>
		<param>HasYieldedField</param>
		<param>TemperatureField</param>
	</list>
	
	
	<!-- Additional numerical control parameters -->
	<param name="shadowDepth"> 1 </param>
	<param name="allowUnbalancing"> True </param>
	<param name="buildElementNodeTbl"> True </param>
	
	<!-- Particle-in-cell control parameters -->
	<param name="particleLayoutType"> random </param> <!-- how are the particles allocated within each cell -->
	<param name="particlesPerCell"> 60 </param> <!-- Number of particles in each cell, for the PIC method -->
	<param name="seed"> 13 </param> <!-- seed for random number generation, should not be changed to allow comparisons -->
	
<!-- ============================================================ -->
<!-- |                                                           |-->
<!-- |                  DEFINE HEAT EQUATION TERMS               |-->
<!-- |                                                           |-->
<!-- ============================================================ -->


<!-- These structures generate the correct terms for the heat equation within the particles. -->
<!-- It is not highly important to understand them but it is crucial to have them here in thermomechanical models -->

	<struct name="components" mergeType="merge">
	
		<!-- Add the radiogenicHeating to the heat equation terms: -->
		<struct name="sourceTerms_thermalEqn">
			<param name="Type">Ppc_Operation</param>
			<param name="Operation"> + </param>
			<list name="Properties">
				<param> radiogenicHeating </param>
			</list>
		</struct>
		
		<!-- Define radiogenic heating -->
		<struct name="radiogenicHeating">
			<param name="Type">Ppc_Operation</param>
			<param name="Operation"> / </param>
			<list name="Properties">
				<param>RadiogenicHeatProductionLabel</param>
				<param>rho_cp</param>
			</list>
		</struct>
		
		<!-- Define heat production per unit of density -->
		<struct name="rho_cp">
			<param name="Type">Ppc_Operation</param>
			<param name="Operation"> * </param>
			<list name="Properties">
				<param>DensityLabel</param>
				<param>CpLabel</param>
			</list>
		</struct>
		
		<!-- Create the heat equation -->
		<struct name="thermalEqn">
			<param name="Type">VectorAssemblyTerm_NA__F</param>
			<param name="ForceVector">residual</param>
			<param name="functionLabel">sourceTerms_thermalEqn</param>
			<param name="Swarm">picIntegrationPoints</param>
			<param name="Manager">default_ppcManager</param>
		</struct>
		
		<!-- Define viscous heating  -->
		<struct name="viscousHeating">
			<param name="Type"> ViscousHeatingTermPpc </param>
			<param name="ForceVector">residual</param>
			<param name="EnergyEqn">EnergyEqn</param>
			<param name="Swarm">picIntegrationPoints</param>
			<param name="DeviatoricStressField"> recoveredDeviatoricStressField </param>
			<param name="StrainRateField"> StrainRateField </param>
			<param name="DensityLabel"> DensityLabel </param>
			<param name="CpLabel"> CpLabel </param>
			<param name="ScalingFactor"> 1.0 </param>
		</struct>
		
		<!-- Define adiabatic heating  -->
		<struct name="adiabaticHeating">
			<param name="Type"> AdiabaticHeatingTermPpc </param>
			<param name="ForceVector"> residual </param>
			<param name="EnergyEqn"> EnergyEqn </param>
			<param name="Swarm"> picIntegrationPoints </param>
			<param name="VelocityField"> VelocityField </param>
			<param name="TemperatureField"> TemperatureField </param>
			<param name="PressureField"> PressureField </param>
			<param name="CpLabel"> CpLabel </param>
			<param name="ThermalExpansivityLabel"> ThermalExpansivityLabel </param>
			<param name="ExternalFunction"> 1.0 </param>
		</struct>
		
		<!-- Define the residual force term  -->
		<struct name="defaultResidualForceTerm" mergeType="replace">
			<param name="Type">SUPGAdvDiffTermPpc</param>
			<param name="ForceVector">residual</param>
			<param name="EnergyEqn">EnergyEqn</param>
			<param name="Swarm">picIntegrationPoints</param>
			<param name="VelocityField">VelocityField</param>
			<param name="PhiField">TemperatureField</param>
			<param name="DiffusivityLabel">DiffusivityLabel</param>
		</struct>
	</struct>
	
	<!-- Create a pressure field within the particles -->
	<struct name="components" mergeType="merge">
		<struct name="default_pressure_ppc">
			<param name="Type">Ppc_Variable</param>
			<param name="FieldVariable"> PressureField </param>
			<param name="ReferenceSwarm"> passiveTracerSwarm </param>
		</struct>
	</struct>
	
	<!-- Add a diffusivity to the particles -->
	<struct name="components" mergeType="merge">
		<struct name="diffusivityPpc" mergeType="replace">
			<param name="Type">Ppc_Constant</param>
			<param name="Value" units="m*m/s">1e16</param>
		</struct>
	</struct>
	
	<!-- Define the value for the Courant factor (balance between grid spacing, velocity and time) -->
	<param name="courantFactor">0.5</param>
	
	<!-- Allow for periodic boundaries -->
	<struct name="components" mergeType="merge">
		<struct name="linearMeshGenerator" mergeType="merge">
			<param name="periodic_x">True</param>
		</struct>
		<struct type="struct" name="sourceTerm" mergeType="replace">
			<param name="Type">DummyComponent</param>
		</struct>
	</struct>
</StGermainData>
